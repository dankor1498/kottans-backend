## Батутні функції
### Trampoline functions

**Ціль:** для оптимізації рекурсії і запобігання винятків переповнення стека при рекурсивних викликах з великим заглибленням в рекурсію.

**Приклад:**

```js
function repeat(operation, num) {
  return function () {
    if (num <= 0) return;
    operation();
    return repeat(operation, --num);
  };
}

function trampoline(fn) {
  while (fn && typeof fn === "function") {
    fn = fn();
  }
}

module.exports = function (operation, num) {
  trampoline(function () {
    return repeat(operation, num);
  });
};
```
**Пояснення:** Проблема зі звичайною рекурсією полягає в тому, що кожен рекурсивний виклик додає кадр стека в стек викликів, який ви можете візуалізувати як піраміду викликів.

Проблема полягає в тому, що розмір стека обмежений, і додавання цих кадрів може привести до переповнення стека. Залежно від розміру стека, велика кількість рекурсивних викликів може привести до переповнення стека. Ось чому регулярна рекурсія в C#, JavaScript може вважатися небезпечною.

Оптимальна модель виконання - щось на зразок батута замість піраміди, де кожен рекурсивний виклик виконується на місці і не складається в стек викликів.

Перший очевидний спосіб - позбутися від рекурсії і переписати код так, щоб він був ітеративним.

Коли це неможливо, нам потрібен трохи складніший код, в якому замість безпосереднього виконання рекурсивних кроків ми будемо використовувати функцію вищого порядку для повернення функції-оболонки замість безпосереднього виконання рекурсивного кроку і дозволимо іншій функції контролювати виконання.

У нашому прикладі функція ***repeat*** обертає звичайний рекурсивний виклик функцією і повертає цю функцію замість виконання рекурсивного виклику.

Повернута функція - це наступний крок рекурсивного виконання, а батут - це механізм для виконання цих кроків контрольованим і ітеративним чином в циклі while.

**Порядок виконання коду:**

1. В функцію ***trampoline*** передається обернута рекурсивна функція, для першого виклику в циклі.

2. В циклі ***while*** відбувається перевірка типу парметра ***fn***, якщо він не є функцією то цикл припиняється і вертається фінальний результат.

3. Спочатку виконується функція яку ми передали в ***trampoline***, і вона вертає результат виклику функції ***repeat*** - це функція.

4. Так як типом поверненої функції є інша функція то цикл виконується, і запускається функція ***fn*** яка є рекурсивною, в ній виконується перший раз ***operation*** і знову викликається ***repeat***.

5. Даний виклик знову вертає функцію => спрацьовує цикл => викликається функція ***operation*** => спрацьовує новий виклик ***repeat***...

Таким чином, єдина мета функції-батута полягає в тому, щоб контролювати виконання ітеративним способом, і це гарантує, що в стеці може бути тільки один кадр стека в будь-який момент часу.

Використання батута, очевидно, менш продуктивно, ніж проста рекурсія, оскільки ми «блокуємо» нормальний рекурсивний потік, але це набагато безпечніше.